var lecturer =
[
	[
		{
			"Name": "0",
			"Lecture": 1,
			"Slide": "0",
			"Line": "Today, we're diving into the exciting world of programming."
		},
		{
			"Name": "1",
			"Lecture": 1,
			"Slide": "0",
			"Line": "Programming is a fundamental skill in today's technology-driven world."
		},
		{
			"Name": "2",
			"Lecture": 1,
			"Slide": "0",
			"Line": "It's the art and science of instructing computers to perform tasks, solve problems, and create new opportunities."
		},
		{
			"Name": "3",
			"Lecture": 1,
			"Slide": "0",
			"Line": "Programming is everywhere in the apps on your phone, the websites you visit, the games you play, and the systems that run modern businesses."
		},
		{
			"Name": "4",
			"Lecture": 1,
			"Slide": "0",
			"Line": "It's a skill that will empower you to build, innovate, and understand the digital world around you."
		},
		{
			"Name": "5",
			"Lecture": 1,
			"Slide": "0",
			"Line": "But more than just writing code, programming teaches you how to think logically and systematically."
		},
		{
			"Name": "6",
			"Lecture": 1,
			"Slide": "0",
			"Line": "It's about breaking down complex problems into manageable pieces and finding efficient solutions."
		},
		{
			"Name": "7",
			"Lecture": 1,
			"Slide": "0",
			"Line": "Whether you end up pursuing a career in tech or another field, the problem-solving skills you gain from programming will be invaluable."
		},
		{
			"Name": "8",
			"Lecture": 1,
			"Slide": "1",
			"Line": "In this course, we'll be learning programming using Ruby."
		},
		{
			"Name": "9",
			"Lecture": 1,
			"Slide": "1",
			"Line": "You might be wondering, why Ruby? What makes it special?"
		},
		{
			"Name": "10",
			"Lecture": 1,
			"Slide": "1",
			"Line": "Ruby is a powerful and versatile programming language, known for its simplicity and elegance."
		},
		{
			"Name": "11",
			"Lecture": 1,
			"Slide": "1",
			"Line": "It was designed to make programming both enjoyable and productive, and it's often described as a language that feels natural to write."
		},
		{
			"Name": "12",
			"Lecture": 1,
			"Slide": "1",
			"Line": "Here are a few reasons why we've chosen Ruby: simplicity, readability, flexibility, community and resources."
		},
		{
			"Name": "13",
			"Lecture": 1,
			"Slide": "2",
			"Line": "Throughout this course, you'll learn the fundamentals of programming everything from variables, loops, and conditionals to more advanced topics like object-oriented programming and web development with Ruby on Rails."
		},
		{
			"Name": "14",
			"Lecture": 1,
			"Slide": "2",
			"Line": "We'll start with the basics, building a solid foundation, and gradually introduce more complex concepts as you become more comfortable with coding."
		},
		{
			"Name": "15",
			"Lecture": 1,
			"Slide": "2",
			"Line": "By the end of this course, you'll not only understand how to write Ruby code, but you'll also have developed the problem-solving skills that are essential for any programmer."
		},
		{
			"Name": "16",
			"Lecture": 1,
			"Slide": "3",
			"Line": "Let's get started! Our first few classes will focus on setting up your development environment, understanding the basics of Ruby syntax, and writing your first programs."
		},
		{
			"Name": "17",
			"Lecture": 1,
			"Slide": "3",
			"Line": "Don't worry if you've never coded before everyone starts as a beginner, and we'll guide you through every step."
		},
		{
			"Name": "18",
			"Lecture": 1,
			"Slide": "3",
			"Line": "Remember, programming is a journey."
		},
		{
			"Name": "19",
			"Lecture": 1,
			"Slide": "3",
			"Line": "It's okay to make mistakes and ask questions that's how you learn and grow."
		},
		{
			"Name": "20",
			"Lecture": 1,
			"Slide": "3",
			"Line": "We're here to help you succeed, so don't hesitate to reach out for support when you need it."
		},
		{
			"Name": "21",
			"Lecture": 1,
			"Slide": "3",
			"Line": "I'm excited to see what you'll create with Ruby and how you'll apply these skills in your academic and professional life."
		},
		{
			"Name": "23",
			"Lecture": 1,
			"Slide": "4",
			"Line": "Let's look at a simple Ruby program: the classic Hello, World! example."
		},
		{
			"Name": "24",
			"Lecture": 1,
			"Slide": "4",
			"Line": "This will introduce you to basic Ruby syntax and how to print text to the console."
		},
		{
			"Name": "25",
			"Lecture": 1,
			"Slide": "4",
			"Line": "Here's the code."
		},
		{
			"Name": "26",
			"Lecture": 1,
			"Slide": "4",
			"Line": "In this example, puts is a Ruby method that prints the text 'Hello, World!' to the console."
		},
		{
			"Name": "27",
			"Lecture": 1,
			"Slide": "4",
			"Line": "It's a great way to get started and see immediate results from your code."
		},
		{
			"Name": "28",
			"Lecture": 1,
			"Slide": "4",
			"Line": "Try running this code in your Ruby environment, and you'll see how easy it is to start programming with Ruby!"
		},
	],
	[
		{
			"Name": "30",
			"Lecture": 2,
			"Slide": "1",
			"Line": "Variables are like labeled storage boxes in your program; they hold data that can change as your program runs."
		},
		{
			"Name": "31",
			"Lecture": 2,
			"Slide": "2",
			"Line": "In Ruby, you create a variable by simply assigning a value to a name, like x = 10."
		},
		{
			"Name": "32",
			"Lecture": 2,
			"Slide": "3",
			"Line": "When naming variables, stick to lowercase letters, use underscores for readability, and avoid starting with numbers or using special characters."
		},
		{
			"Name": "33",
			"Lecture": 2,
			"Slide": "4",
			"Line": "One great feature of Ruby is that you can change the value or even the type of a variable at any point in your code."
		},
		{
			"Name": "34",
			"Lecture": 2,
			"Slide": "5",
			"Line": "For values that shouldn't change, you can use constants written in uppercase; just remember that Ruby won't enforce immutability but will warn you."
		},
		{
			"Name": "35",
			"Lecture": 2,
			"Slide": "6",
			"Line": "It's also important to know where your variables can be accessed, so understanding the different types local, instance, class, and global will help you control their scope."
		},
		{
			"Name": "36",
			"Lecture": 2,
			"Slide": "7",
			"Line": "When working with strings, Ruby makes it easy to include variables directly inside them using #{}, which keeps your code clean and readable."
		},
		{
			"Name": "37",
			"Lecture": 2,
			"Slide": "8",
			"Line": "Be careful with common errors like using undefined variables or typos, and use tools like puts and irb to debug your code effectively."
		},
		{
			"Name": "38",
			"Lecture": 2,
			"Slide": "9",
			"Line": "Let's try some hands-on examples, like swapping values between variables or experimenting with reassigning different types to the same variable."
		},
		{
			"Name": "39",
			"Lecture": 2,
			"Slide": "10",
			"Line": "For homework, practice declaring variables with different data types, and try writing a program to calculate the area of a rectangle."
		},
		{
			"Name": "40",
			"Lecture": 2,
			"Slide": "11",
			"Line": "To sum up, variables are the building blocks of Ruby programs, and understanding their behavior and scope is essential for writing clear, efficient code."
		},
	],
	[
		{
			"Name": "41",
			"Lecture": 3,
			"Slide": "1",
			"Line": "In this slide, we introduce the concept of functions, also known as methods in Ruby, which help organize and reuse code effectively."
		},
		{
			"Name": "42",
			"Lecture": 3,
			"Slide": "2",
			"Line": "Here, we discuss how to define a method using the def keyword, followed by method parameters and the method body."
		},
		{
			"Name": "43",
			"Lecture": 3,
			"Slide": "3",
			"Line": "On this slide, we show how to call a method by providing its name, followed by parentheses containing any necessary arguments."
		},
		{
			"Name": "44",
			"Lecture": 3,
			"Slide": "4",
			"Line": "We cover how methods take parameters as input and use arguments when calling the method to pass specific values."
		},
		{
			"Name": "45",
			"Lecture": 3,
			"Slide": "5",
			"Line": "This slide explains how to provide default values for parameters, allowing methods to work with optional arguments."
		},
		{
			"Name": "46",
			"Lecture": 3,
			"Slide": "6",
			"Line": "Here, we highlight how methods return values either explicitly using return or implicitly by the last expression."
		},
		{
			"Name": "47",
			"Lecture": 3,
			"Slide": "7",
			"Line": "By understanding functions and how they work, you can create reusable, maintainable code in Ruby. Functions help break down complex problems into smaller, manageable tasks, enhancing both readability and efficiency."
		},
		{
			"Name": "47",
			"Lecture": 3,
			"Slide": "7",
			"Line": "Now that we've covered defining, calling, and managing methods, let's move on to practice creating and using functions effectively in our programs."
		},
	],
	[
		{
			"Name": "48",
			"Lecture": 4,
			"Slide": "1",
			"Line": "Today, we'll be diving into two key control structures in Ruby: if and case statements."
		},
		{
			"Name": "48",
			"Lecture": 4,
			"Slide": "1",
			"Line": "These are essential tools that allow us to make decisions in our code and execute specific blocks of code based on certain conditions."
		},
		{
			"Name": "49",
			"Lecture": 4,
			"Slide": "2",
			"Line": "Let's begin with the if statement. The if statement is the simplest form of conditional logic. It's used when you have a single condition to evaluate."
		},
		{
			"Name": "49",
			"Lecture": 4,
			"Slide": "2",
			"Line": "If that condition is true, a particular block of code will be executed. If not, the program simply moves on without executing anything. The syntax is straightforward: if condition."
		},
		{
			"Name": "50",
			"Lecture": 4,
			"Slide": "3",
			"Line": "Next, we have the if-else structure. This is used when you need to handle two outcomes one for when the condition is true, and another for when it's false."
		},
		{
			"Name": "50",
			"Lecture": 4,
			"Slide": "3",
			"Line": "The if-else structure provides a way to define what should happen in both scenarios."
		},
		{
			"Name": "51",
			"Lecture": 4,
			"Slide": "4",
			"Line": "Sometimes, we need to check multiple conditions, and that's where if-elsif-else comes into play. With if-elsif-else, we evaluate multiple conditions one after another, ensuring the appropriate code block is executed depending on which condition matches."
		},
		{
			"Name": "52",
			"Lecture": 4,
			"Slide": "5",
			"Line": "Moving on to the case statement, which is particularly useful when dealing with multiple possible values. The case statement provides a clear and concise way to evaluate these values, offering an alternative to if-elsif-else structures."
		},
		{
			"Name": "52",
			"Lecture": 4,
			"Slide": "5",
			"Line": "It allows us to match values against a set of conditions and execute the corresponding code block when a match is found."
		},
		{
			"Name": "53",
			"Lecture": 4,
			"Slide": "6",
			"Line": "The case statement is especially powerful when we're working with ranges. We can specify a range of values and execute different blocks of code based on which range the value falls into."
		},
		{
			"Name": "54",
			"Lecture": 4,
			"Slide": "8",
			"Line": "Lastly, we need to consider when to use if versus case. If you have straightforward, binary conditions, the if statement may be sufficient. However, when dealing with multiple conditions or ranges, the case statement tends to be more readable and maintainable."
		},
		{
			"Name": "55",
			"Lecture": 4,
			"Slide": "9",
			"Line": "In conclusion, both if and case statements are fundamental control structures in Ruby that allow us to write clear, organized code. Understanding when to apply each of these ensures that your programs are efficient and easy to read."
		},
	],
	[
		{
			"Name": "56",
			"Lecture": 5,
			"Slide": "1",
			"Line": "Loops are essential when we need to perform repetitive tasks, saving both time and effort in our code."
		},
		{
			"Name": "57",
			"Lecture": 5,
			"Slide": "2",
			"Line": "In Ruby, we have three main types of loops: for, while, and until, each with specific use cases."
		},
		{
			"Name": "58",
			"Lecture": 5,
			"Slide": "3",
			"Line": "The for loop iterates over a range of numbers or elements in a collection, executing a block of code repeatedly."
		},
		{
			"Name": "59",
			"Lecture": 5,
			"Slide": "4",
			"Line": "Here's an example of how the for loop prints numbers from 1 to 5."
		},
		{
			"Name": "60",
			"Lecture": 5,
			"Slide": "5",
			"Line": "The while loop continues executing as long as the condition is true, ideal for situations where the number of iterations is uncertain."
		},
		{
			"Name": "61",
			"Lecture": 5,
			"Slide": "6",
			"Line": "Let's see how the while loop increments a counter until it reaches 5."
		},
		{
			"Name": "62",
			"Lecture": 5,
			"Slide": "7",
			"Line": "The until loop works in the opposite way, continuing execution until the condition becomes true."
		},
		{
			"Name": "63",
			"Lecture": 5,
			"Slide": "8",
			"Line": "Here's an example demonstrating how the until loop behaves similarly to the while loop, but in reverse."
		},
		{
			"Name": "64",
			"Lecture": 5,
			"Slide": "9",
			"Line": "Control statements like break, next, and redo modify the flow of loops, giving you greater control over iteration."
		},
		{
			"Name": "65",
			"Lecture": 5,
			"Slide": "10",
			"Line": "Let me know if you need further assistance!"
		},
		{
			"Name": "66",
			"Lecture": 6,
			"Slide": "1",
			"Line": "Arrays, also known as lists, are ordered collections of elements that allow us to store and manage multiple pieces of related data in Ruby."
		},
	],
	[
		{
			"Name": "67",
			"Lecture": 6,
			"Slide": "2",
			"Line": "By grouping data together, arrays help us perform operations on multiple elements efficiently and are a fundamental tool in programming."
		},
		{
			"Name": "68",
			"Lecture": 6,
			"Slide": "3",
			"Line": "To create an array in Ruby, you can use square brackets or the Array.new method, which offers flexibility in defining arrays with default values."
		},
		{
			"Name": "69",
			"Lecture": 6,
			"Slide": "4",
			"Line": "Accessing elements in an array is straightforward, as you simply use their index, starting from zero, to retrieve or manipulate specific values."
		},
		{
			"Name": "70",
			"Lecture": 6,
			"Slide": "5",
			"Line": "Arrays are dynamic, and you can easily modify their contents by assigning new values to specific indices as needed."
		},
		{
			"Name": "71",
			"Lecture": 6,
			"Slide": "6",
			"Line": "Ruby provides useful methods like push, pop, shift, and unshift to add or remove elements from arrays in different ways."
		},
		{
			"Name": "72",
			"Lecture": 6,
			"Slide": "7",
			"Line": "To process all elements in an array, you can use iteration methods like each or map, which allow you to perform actions on each element efficiently."
		},
		{
			"Name": "73",
			"Lecture": 6,
			"Slide": "8",
			"Line": "Arrays come with built-in methods to check properties like length, emptiness, or whether a specific element is included."
		},
		{
			"Name": "74",
			"Lecture": 6,
			"Slide": "9",
			"Line": "Ruby supports nested arrays, enabling the creation of multidimensional data structures that can represent complex relationships."
		},
		{
			"Name": "75",
			"Lecture": 6,
			"Slide": "10",
			"Line": "You can extract parts of an array using slicing techniques or ranges, giving you powerful tools to manipulate subsets of data."
		},
		{
			"Name": "76",
			"Lecture": 6,
			"Slide": "11",
			"Line": "Transformation and filtering methods like map and select enable you to create modified versions of arrays or focus on elements that meet specific conditions."
		},
		{
			"Name": "77",
			"Lecture": 6,
			"Slide": "12",
			"Line": "Arrays are indispensable for managing collections of data, and understanding their capabilities is essential for effective Ruby programming."
		},
	],
	[
		{
			"Name": "78",
			"Lecture": 7,
			"Slide": "1",
			"Line": "In Ruby, everything is an object, representing real-world entities with attributes and behaviours like a car that drives or stops."
		},
		{
			"Name": "79",
			"Lecture": 7,
			"Slide": "2",
			"Line": "To create objects, we start with a class, which acts as a blueprint, defined using the class keyword."
		},
		{
			"Name": "80",
			"Lecture": 7,
			"Slide": "3",
			"Line": "Once our class is defined, we can create objects from it by using the new method."
		},
		{
			"Name": "81",
			"Lecture": 7,
			"Slide": "4",
			"Line": "Attributes, stored as instance variables prefixed with @, allow each object to hold its unique data."
		},
		{
			"Name": "82",
			"Lecture": 7,
			"Slide": "5",
			"Line": "To retrieve an object's attributes, we define getter methods, allowing us to access its stored information."
		},
		{
			"Name": "83",
			"Lecture": 7,
			"Slide": "6",
			"Line": "Setter methods, on the other hand, enable us to modify an object's attributes, making it flexible and adaptable."
		},
		{
			"Name": "84",
			"Lecture": 7,
			"Slide": "7",
			"Line": "Here, we see a complete class example, demonstrating how attributes, getters, setters, and object creation work together seamlessly."
		},
		{
			"Name": "85",
			"Lecture": 7,
			"Slide": "8",
			"Line": "Objects also have behaviours, defined by instance methods, which outline what the object can do."
		},
		{
			"Name": "86",
			"Lecture": 7,
			"Slide": "9",
			"Line": "Let's extend our class to include behaviour such as driving bringing our object to life."
		},
		{
			"Name": "87",
			"Lecture": 7,
			"Slide": "10",
			"Line": "The initialize method is a special constructor, automatically called to set up an object's initial state."
		},
		{
			"Name": "88",
			"Lecture": 7,
			"Slide": "11",
			"Line": "In conclusion, objects are at the heart of Ruby; mastering their creation and manipulation is key to becoming a skilled Ruby programmer."
		},
	],
	[
		{
			"Name": "89",
			"Lecture": 8,
			"Slide": "1",
			"Line": "In Ruby, working with multiple classes allows us to create systems where each class has its own distinct purpose, making our code more organised and modular."
		},
		{
			"Name": "90",
			"Lecture": 8,
			"Slide": "2",
			"Line": "By defining separate classes like Student and Course, we can clearly structure responsibilities and avoid unnecessary entanglements in our code."
		},
		{
			"Name": "91",
			"Lecture": 8,
			"Slide": "3",
			"Line": "Objects from different classes interact by creating instances of those classes, such as a Student enrolling in a Course."
		},
		{
			"Name": "92",
			"Lecture": 8,
			"Slide": "4",
			"Line": "Adding relationships between classes, like a Student having multiple Course objects, allows for real-world modelling in our programs."
		},
		{
			"Name": "93",
			"Lecture": 8,
			"Slide": "5",
			"Line": "We can enhance these interactions by introducing methods that facilitate and manage relationships, such as listing courses for a student."
		},
		{
			"Name": "94",
			"Lecture": 8,
			"Slide": "6",
			"Line": "Encapsulation ensures each class, like Course, takes care of its own data and behaviour, making our code easier to maintain and debug."
		},
		{
			"Name": "95",
			"Lecture": 8,
			"Slide": "7",
			"Line": "A library system with Book, Member, and Loan classes demonstrates how multiple classes work together to handle complex data."
		},
		{
			"Name": "96",
			"Lecture": 8,
			"Slide": "8",
			"Line": "When sharing data between objects, like passing a Book object to both a Library and a Loan, references make data sharing efficient and dynamic."
		},
		{
			"Name": "97",
			"Lecture": 8,
			"Slide": "9",
			"Line": "We can manage object relationships effectively by using collections like arrays or hashes, such as storing all library books in an array for easy access."
		},
		{
			"Name": "98",
			"Lecture": 8,
			"Slide": "10",
			"Line": "To maintain clean and maintainable code, avoid tight coupling between classes, keeping each one focused on its specific role with minimal dependency on others."
		},
		{
			"Name": "99",
			"Lecture": 8,
			"Slide": "11",
			"Line": "By following these practices, we can design robust and scalable systems where multiple classes interact harmoniously, laying a strong foundation for complex Ruby programs."
		},
	],
	[
		{
			"Name": "100",
			"Lecture": 9,
			"Slide": "1",
			"Line": "In Ruby, inheritance allows one class to inherit properties and methods from another, enabling code reuse and extension."
		},
		{
			"Name": "101",
			"Lecture": 9,
			"Slide": "2",
			"Line": "When we define a subclass in Ruby using the < operator, it inherits the superclass's methods and attributes, but we can also override them as needed."
		},
		{
			"Name": "102",
			"Lecture": 9,
			"Slide": "3",
			"Line": "Polymorphism allows objects of different classes to respond to the same method, but each object may implement it differently, which is key to flexible code."
		},
		{
			"Name": "103",
			"Lecture": 9,
			"Slide": "4",
			"Line": "Method overriding lets subclasses redefine methods from their superclass to provide more specific behaviour for the subclass."
		},
		{
			"Name": "104",
			"Lecture": 9,
			"Slide": "5",
			"Line": "The super keyword is used to call methods from a superclass, allowing subclasses to extend or modify inherited functionality."
		},
		{
			"Name": "105",
			"Lecture": 9,
			"Slide": "6",
			"Line": "The self keyword in Ruby refers to the current object or class, and is essential for working with class methods and instance methods."
		},
		{
			"Name": "106",
			"Lecture": 9,
			"Slide": "7",
			"Line": "Although Ruby doesn't have explicit abstract classes or interfaces, we can simulate these concepts by raising errors in methods that must be overridden in subclasses."
		},
		{
			"Name": "107",
			"Lecture": 9,
			"Slide": "8",
			"Line": "Ruby supports multiple inheritance through mixins, where classes include modules to gain shared functionality, bypassing the need for single inheritance."
		},
		{
			"Name": "108",
			"Lecture": 9,
			"Slide": "9",
			"Line": "Ruby's method lookup path shows how Ruby finds methods on objects, starting from the object's class and going up the inheritance chain."
		},
		{
			"Name": "109",
			"Lecture": 9,
			"Slide": "10",
			"Line": "The respond_to? method is a great tool to check if an object can respond to a method, ensuring safe polymorphism."
		},
		{
			"Name": "110",
			"Lecture": 9,
			"Slide": "11",
			"Line": "Mastering inheritance, polymorphism, and other OOP concepts will help you write flexible, reusable code in Ruby that can easily scale with your needs."
		},
		{
			"Name": "111",
			"Lecture": 10,
			"Slide": "1",
			"Line": "Linear search is a simple but often inefficient way to find an element in a collection by checking each element one by one."
		},
	],
	[
		{
			"Name": "112",
			"Lecture": 10,
			"Slide": "2",
			"Line": "In contrast, binary search allows us to find an element more efficiently, but requires the collection to be sorted beforehand."
		},
		{
			"Name": "113",
			"Lecture": 10,
			"Slide": "3",
			"Line": "Ruby offers the .include? method, a convenient way to check if a specific element exists in an array."
		},
		{
			"Name": "114",
			"Lecture": 10,
			"Slide": "4",
			"Line": "If you need to search for an element that meets a specific condition, you can use Ruby's .find method to retrieve the first match."
		},
		{
			"Name": "115",
			"Lecture": 10,
			"Slide": "5",
			"Line": "Sorting arrays is simple with Ruby's built-in .sort method, which arranges elements in ascending order by default."
		},
		{
			"Name": "116",
			"Lecture": 10,
			"Slide": "6",
			"Line": "To reverse the order and sort in descending fashion, you can chain .reverse to the .sort method."
		},
		{
			"Name": "117",
			"Lecture": 10,
			"Slide": "7",
			"Line": "If you want to sort a hash by its keys, Ruby's .sort method will convert it to an array, and we can convert it back to a hash using to_h."
		},
		{
			"Name": "118",
			"Lecture": 10,
			"Slide": "8",
			"Line": "Similarly, sorting a hash by its values can be achieved with .sort_by, allowing us to specify sorting criteria for the hash values."
		},
		{
			"Name": "119",
			"Lecture": 10,
			"Slide": "9",
			"Line": "Ruby also supports advanced sorting techniques with blocks, where you can customize the sorting logic as per your needs, such as sorting in descending order with a custom block."
		},
		{
			"Name": "120",
			"Lecture": 10,
			"Slide": "10",
			"Line": "Finally, when choosing a sorting or searching algorithm, it's crucial to consider performance, as more efficient methods like binary search or custom sorting may be required for larger datasets."
		},
	],
	[
		{
			"Name": "121",
			"Lecture": 11,
			"Slide": "1",
			"Line": "Ruby on Rails is an open-source web application framework written in Ruby, designed to make web development faster and easier through its convention over configuration approach."
		},
		{
			"Name": "122",
			"Lecture": 11,
			"Slide": "2",
			"Line": "Ruby on Rails was created by David Heinemeier Hansson in 2003 and has since become one of the most popular frameworks for web development."
		},
		{
			"Name": "123",
			"Lecture": 11,
			"Slide": "3",
			"Line": "Ruby on Rails follows the Model-View-Controller (MVC) architecture, making it easy to separate your application into data, user interface, and control layers."
		},
		{
			"Name": "124",
			"Lecture": 11,
			"Slide": "4",
			"Line": "The MVC architecture separates the logic into three key components: Model for data, View for UI, and Controller for managing user requests and interactions."
		},
		{
			"Name": "125",
			"Lecture": 11,
			"Slide": "5",
			"Line": "Rails follows the principle of Convention over Configuration, meaning it assumes the default behaviour for most things, saving developers time and effort in setup."
		},
		{
			"Name": "126",
			"Lecture": 11,
			"Slide": "6",
			"Line": "Ruby on Rails embraces the Don't Repeat Yourself (DRY) principle, encouraging the reuse of code to increase efficiency and reduce redundancy."
		},
		{
			"Name": "127",
			"Lecture": 11,
			"Slide": "7",
			"Line": "The directory structure in Rails is designed to be logical and consistent, making it easy to locate models, views, controllers, and configuration files."
		},
		{
			"Name": "128",
			"Lecture": 11,
			"Slide": "8",
			"Line": "Setting up a new Ruby on Rails project is straightforward: Install Ruby and Rails, then use the rails new command to generate a new application, followed by running rails server to start the development server."
		},
		{
			"Name": "129",
			"Lecture": 11,
			"Slide": "9",
			"Line": "In Rails, routes define how URLs map to controller actions, and controllers process incoming requests, sending responses to views or returning data to the user."
		},
		{
			"Name": "130",
			"Lecture": 11,
			"Slide": "10",
			"Line": "Active Record in Rails is the tool that allows you to interact with the database through Ruby objects, while migrations help you define and modify the database schema."
		},
		{
			"Name": "131",
			"Lecture": 11,
			"Slide": "11",
			"Line": "Rails views use Embedded Ruby (ERB) to inject Ruby code into HTML templates, dynamically generating content for the user interface."
		},
		{
			"Name": "132",
			"Lecture": 11,
			"Slide": "12",
			"Line": "Ruby on Rails benefits from a vibrant ecosystem, with an active community that contributes gems and plugins to enhance its functionality, making development faster and more flexible."
		},
	],
	[
		{
			"Name": "133",
			"Lecture": 12,
			"Slide": "1",
			"Line": "We began by understanding Ruby's syntax, laying the foundation for writing clear and concise code."
		},
		{
			"Name": "134",
			"Lecture": 12,
			"Slide": "2",
			"Line": "Next, we explored variables and data types, which are fundamental to managing and manipulating information in your programs."
		},
		{
			"Name": "135",
			"Lecture": 12,
			"Slide": "3",
			"Line": "We then moved on to functions, helping you structure your code into reusable blocks that make development more efficient."
		},
		{
			"Name": "136",
			"Lecture": 12,
			"Slide": "4",
			"Line": "Conditional statements such as if, else, and case allowed you to control the flow of your program, guiding it to make decisions based on different conditions."
		},
		{
			"Name": "137",
			"Lecture": 12,
			"Slide": "5",
			"Line": "Loops, including while and each, empowered you to repeat actions, making it easier to handle repetitive tasks or process collections of data."
		},
		{
			"Name": "138",
			"Lecture": 12,
			"Slide": "6",
			"Line": "We explored arrays, one of Ruby's most useful data structures, and you learned how to store and manipulate collections of data efficiently."
		},
		{
			"Name": "139",
			"Lecture": 12,
			"Slide": "7",
			"Line": "Object-oriented programming came next, where we focused on creating classes and instances, understanding how objects communicate with each other."
		},
		{
			"Name": "140",
			"Lecture": 12,
			"Slide": "8",
			"Line": "We then advanced to multiple classes and explored how they can work together to build more complex systems."
		},
		{
			"Name": "141",
			"Lecture": 12,
			"Slide": "9",
			"Line": "Inheritance and polymorphism enabled us to write more flexible and reusable code, unlocking the power of OOP."
		},
		{
			"Name": "142",
			"Lecture": 12,
			"Slide": "10",
			"Line": "We also covered searching and sorting algorithms, which are vital for handling large datasets effectively in Ruby."
		},
		{
			"Name": "143",
			"Lecture": 12,
			"Slide": "11",
			"Line": "Finally, we ventured into Ruby on Rails, where we saw how Ruby extends its power into web development, allowing you to build dynamic, database-driven websites."
		},
		{
			"Name": "144",
			"Lecture": 12,
			"Slide": "12",
			"Line": "As we close, remember that the concepts we've covered are just the beginning keep experimenting with Ruby, and continue building your skills as a developer."
		},
		{
			"Name": "145",
			"Lecture": 12,
			"Slide": "13",
			"Line": "To prepare for the exam, review all key concepts we've covered, practice coding exercises, and focus on understanding the core Ruby principles such as syntax, object-oriented programming, algorithms, and Ruby on Rails."
		}
	]
]